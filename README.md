# Шукшин Владимир_ИТ-16_лаб_№4

# Вариант 6
## Задание 2
Структурные шаблоны
### Задача 1
Текст задачи
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:
public void meow();
### Алгоритм решения
Создаем кота с заданным именем, используя класс Cat.
Создаем объект-обёртку CountingMeowable, передав в его конструктор созданного кота.
Эта обёртка будет передавать вызов meow() коту, но при этом считать количество вызовов.
Передаем обёртку в метод Funs.meowsCare().
Внутри метода meowsCare() происходит 5 вызовов meow(), каждый из которых:
Вызывает meow() у кота (печатает "Имя: мяу!").
Увеличиваеем счётчик в обёртке.
После завершения метода получаем количество мяуканий через getMeowCount() у обёртки. Выводим результат на экран.

<img width="183" height="158" alt="image" src="https://github.com/user-attachments/assets/eb8d38ec-0fd6-48df-bab9-43308c8d55a5" />

## Задание 3
Список
### Задача 4
Текст задачи
Составить программу, которая вставляет в список L за первым вхождением элемента E все
элементы списка L, если E входит в L
### Алгоритм решения
Делаем последовательный обходе исходного списка L с добавлением каждого элемента в новый список result.
Если текущий элемент равен E и элемент E ещё не был найден ранее, то сразу после добавления этого элемента E в result вставляются все элементы из списка L.
Устанавливаем флаг found в true, гарантирующий однократность вставки.
Если же элемент E в списке L отсутствует, алгоритм просто возвращает полную копию исходного списка.

<img width="350" height="68" alt="image" src="https://github.com/user-attachments/assets/d14ad6c7-a7d4-471f-a073-eaad51065085" />
<img width="289" height="65" alt="image" src="https://github.com/user-attachments/assets/0704967e-797f-46b5-9d98-cbbed574087f" />

## Задание 4
Мап
### Задача 6
Текст задачи
В некотором вузе абитуриенты проходили предварительное тестирование, по результатам
которого они могут быть допущены к сдаче вступительных экзаменов в первом потоке.
Тестирование проводится по трём предметам, по каждому предмету абитуриент может набрать
от 0 100 баллов. При этом к сдаче экзаменов в первом потоке допускаются абитуриенты,
набравшие по результатам тестирования не менее 30 баллов по каждому из трёх предметов,
причём сумма баллов должна быть не менее 140. На вход программы подаются сведения о
результатах предварительного тестирования. Известно, что общее количество участников
тестирования не превосходит 500.
В первой строке вводится количество абитуриентов, принимавших участие в тестировании, N.
Далее следуют N строк, имеющих следующий формат:
<Фамилия><Имя><Баллы>
Здесь <Фамилия> – строка, состоящая не более чем из 20 символов; <Имя> – строка, состоящая не
более чем из 15 символов, <Баллы> – строка, содержащая два целых числа, разделенных
пробелом – баллы, полученные на тестировании по каждому из трёх предметов. При этом
<Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом. Пример входной строки:
Романов Вельямин 48 39 55
Напишите программу, которая будет выводить на экран фамилии и имена абитуриентов,
допущенных к сдаче экзаменов в первом потоке. При этом имена и фамилии можно
выводить в произвольном порядке.
### Алгоритм решения
Создаем функции чтения данных, проверки условий допуска и вывода результатов.
Сначала считывается количество абитуриентов, затем для каждого обрабатывается строка - извлекаются фамилия, имя и три оценки.
Функция checkAdmission проверяет, что каждая оценка не меньше 30, а их сумма не меньше 140.
Если условия выполнены, абитуриент добавляется в список допущенных; данные хранятся в Map (имя->баллы) и List (допущенные).
После обработки всех записей функция вывода печатает фамилии и имена допущенных из списка в произвольном порядке, с обработкой возможных ошибок формата данных.

<img width="434" height="202" alt="image" src="https://github.com/user-attachments/assets/6420ac4d-c884-4d81-8919-6a4e38b05f8b" />

## Задание 5
Сет
### Задача 8
Текст задачи
Файл содержит текст на русском языке. Сколько букв русского алфавита не встречается в этом
тексте?
### Алгоритм решения
Создаем статический метод analyzeText(), который принимает строку текста и возвращает количество отсутствующих букв русского алфавита. 
Сначала текст приводится к нижнему регистру методом toLowerCase(). 
Для определения русских букв используется вспомогательная функция isRussianLetter().
Основная логика построена на работе с HashSet<Character> — множеством для хранения уникальных найденных русских букв, куда через цикл for-each и метод add() помещаются все подходящие символы текста.
Затем создаются два ArrayList<Character> — для встречающихся и отсутствующих букв.
Последовательным перебором предопределённого массива русского алфавита и проверкой через contains() на наличие в множестве каждая буква распределяется в соответствующий список.
Форматированный вывод списков обеспечивает вспомогательный метод toString(), который выводит элементы через запятую или "(нет)" для пустых списков. 
Функция readFile() с использованием BufferedReader и FileReader обеспечивает чтение текстового файла для передачи в метод анализа.

<img width="842" height="179" alt="image" src="https://github.com/user-attachments/assets/47629311-b51d-4c65-b0e2-23a2cabe6d53" />

## Задание 6
Очередь
### Задача 2
Текст задачи
По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить
очередь из элементов 1, 2, 3, 3, 2, 1).
### Алгоритм решения
Метод buildQueueFromList(LinkedList<Integer> list) реализует следующий алгоритм: 
Сначала он создаёт новую очередь и копирует в неё все элементы исходного списка в прямом порядке с помощью addAll().
В цикле, проходя по индексам списка от конца к началу, последовательно извлекает каждый элемент методом get(i).
Добавляет его в конец очереди, что формирует итоговую последовательность, состоящую из элементов списка L, за которыми следуют те же элементы в обратном порядке.

<img width="367" height="50" alt="image" src="https://github.com/user-attachments/assets/485f8a99-f3d2-44c1-87ba-dd12d5565cfd" />

## Задание 7
Стрим
### Задача 1
Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
• Координата Х: число.
• Координата Y: число.
• Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
• Координата начала: Точка
• Координата конца: Точка
• Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная
линия представляет собой набор следующих характеристик:
• Имеет массив Точек, через которые линия проходит.
• Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это
результат приведения к строке Точки с номером N
### Алгоритм решения
Создаем классы Point,Line,Polyline.
Возьмём исходный набор точек. Применим метод distinct() для удаления точек с одинаковыми координатами X и Y (используя переопределенные equals() и hashCode() в классе Point).
Сортируем оставшиеся точки по возрастанию координаты X с помощью sorted(Comparator.comparingDouble(Point::getX)).
Преобразуем каждую точку, заменив её координату Y на абсолютное значение через map(p -> new Point(p.getX(), Math.abs(p.getY()))).
Собираем результат в список с помощью collect(Collectors.toList()), который передаётся в конструктор Polyline для создания итоговой ломаной линии.

<img width="890" height="50" alt="image" src="https://github.com/user-attachments/assets/965044ea-90b4-46f9-b4ad-6f8c62ab155e" />

### Задача 2
Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]
### Алгоритм решения
Чтение файла построчно через BufferedReader, фильтрация непустых строк. 
Разделение каждой строки с разделителем : на имя и номер. 
Отбрасываются записи без номера (пустой номер или отсутствие части после :).
Для оставшихся записей имя форматируется: приведение к нижнему регистру с первой заглавной буквой. 
Далее данные группируются в Map<String, List<String>>, где ключ — номер, а значение — список отформатированных имён, используя Collectors.groupingBy с Collectors.mapping для преобразования имён.
Итоговая мапа возвращается как результат.

<img width="247" height="135" alt="image" src="https://github.com/user-attachments/assets/49e31dd6-a2e6-4344-abae-7ceaf785bd8b" />
